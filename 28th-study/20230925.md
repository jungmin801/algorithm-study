20230925 코드 리뷰
===========================

### 문자열 내 마음대로 정렬하기

```jsx
// 1. sort에서 a,b를 비교하여 -1이면 작은 것이 앞으로 정렬. 1이면 작은 것이 뒤에 정렬.
// 2. a[n]를 b[n] 비교하여 a[n]이 더 작으면 -1.
// 3. 같은 문자라면 해당 단어 자체를 비교하여 정렬. 

function solution(strings, n) {
    return strings.sort((a,b) => {
       if(a[n]<b[n]) return -1;
       else if (a[n] === b[n]) return a < b ? -1 : 1;
    });
}
```

**코드 수정**
- a[n] > b[n]인 경우에 대해 예외처리를 안해줘도 답이 나오긴 하지만 명확하지 않다.
- sort의 경우 명시하지 않으면 기본 오름차순 정렬이 되며, 비교하는 순서가 보장되지 않는 것으로 추측된다. (자바스크립트 엔진이 자체적으로 처리하는 듯함.)
- 따라서 아래와 같이 a[n]>b[n]인 경우를 명시하는 것이 정확하다.

```jsx
function solution(strings, n) {
    return strings.sort((a,b) => {
        if(a[n]<b[n]) return -1;
        else if (a[n]>b[n]) return 1; 
        else if (a[n] === b[n]) return a < b ? -1 : 1;
    });
}
```

**새로 배운 내용**
**localeCompare**
- 참조 문자열이 정렬 순으로 지정된 문자열 앞 혹은 뒤에 오는지 또는 동일한 문자열인지 나타내는 수치를 반환한다.

```jsx
// "a"는 "c" 전에 위치하므로 음수 값을 반환
"a".localeCompare("c"); // -2 혹은 -1 (또는 다른 음수 값)

// 알파벳 순으로 단어 "check"는 "against"보다 뒤에 위치하므로 양수 값을 반환
"check".localeCompare("against"); // 2 혹은 1 (또는 다른 양수 값)

// "a"와 "a"는 서로 동등하므로 중립 값 0을 반환
"a".localeCompare("a"); // 0
```


### 비밀지도

**비트연산자**
- bit 단위로 논리연산을 할 때 사용한다. 

1. 비트 AND 연산자 (&): 두 비트가 모두 1인 경우에만 결과가 1이 되고, 나머지 경우에는 0이 됩니다. 예를 들어, 1010 & 1100은 1000이 됩니다.

2. 비트 OR 연산자 (|): 두 비트 중 하나 이상이 1이면 결과가 1이 되고, 둘 다 0인 경우에만 0이 됩니다. 예를 들어, 1010 | 1100은 1110이 됩니다.

3. 비트 XOR 연산자 (^): 두 비트가 서로 다른 경우에만 결과가 1이 되고, 같은 경우에는 0이 됩니다. 예를 들어, 1010 ^ 1100은 0110이 됩니다.

4. 비트 NOT 연산자 (~): 단일 비트를 뒤집어서 1을 0으로, 0을 1로 바꿉니다. 예를 들어, ~1010은 0101이 됩니다.


**padStart**
- 현재 문자열의 시작을 다른 문자열로 채워, 주어진 길이를 만족하는 새로운 문자열을 반환합니다. 채워넣기는 대상 문자열의 시작(좌측)부터 적용됩니다.

```jsx
const str = "11";
console.log(str.padStart(5,"0")); // 00011
```